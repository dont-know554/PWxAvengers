<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap"
    rel="stylesheet" />
  <link rel="icon" type="image/png" sizes="any" href="https://www.pw.live/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <title>PW x AVENGERS</title>
  <script disable-devtool-auto="true" src="https://cdn.jsdelivr.net/npm/disable-devtool" disable-select="true"
    disable-copy="true" disable-cut="true" disable-paste="false"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Cloudflare Web Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "6aeea0aeb5c54e3eac0fc4f0db759346"}'></script><!-- End Cloudflare Web Analytics -->
</head>

<body>
  <!-- Loading Spinner Overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <p class="loading-text">Loading...</p>
  </div>

  <!-- Modern Notification Popup -->
  <div id="notificationPopup" class="notification-popup" style="display: none;">
    <div class="notification-content">
      <i class="fas fa-exclamation-triangle notification-icon"></i>
      <span class="notification-message"></span>
    </div>
  </div>

  <div class="container">
    <header class="top-bar">
      <h1 class="title">PW<i id="header-icon" class="fa-solid fa-xmark"></i>AVENGERS</h1>
    </header>

    <input type="text" id="searchInput" placeholder="üîç Enter Batch name" />

    <div class="grid" id="main"></div>
    <div id="loadMoreBatchesWrapper" style="text-align: center; margin: 2rem 0; display: none;">
      <button id="loadMoreBatchesBtn">
        <span>Load More</span>
        <i class="fas fa-chevron-down"></i>
      </button>
    </div>
    <div class="back-btn" id="backBtn" style="display:none;">‚Üê Back</div>

    <div class="today-classes-wrapper" id="todayWrapper" style="display: none;">
      <div class="today-classes-title">Live Classes</div>
      <div class="today-scroll-container" id="todayScrollContainer"></div>
    </div>


    <div id="subjects" class="subjects-container" style="display: none;"></div>
    <!-- Grid container for chapters -->
    <div id="chaptersDiv" class="card-grid" style="display: none;"></div>

    <!-- Load more trigger (outside grid) -->
    <div id="chapterLoadMoreWrapper" style="display: none;">
      <div id="loadMoreChapters" style="width: 100%; height: 1px;"></div>
    </div>


    <div style="text-align:center; margin-top: 20px; display:none;" id="chapterLoadMoreWrapper">
      <button id="chapterLoadMoreBtn" class="load-more-btn">
        Load More Chapters
      </button>
    </div>

    <div id="lectureSection" style="display:none;">
      <div class="lecture-tabs">
        <button id="tab-lectures" onclick="switchLectureTab('lectures')">Lectures</button>
        <button id="tab-notes" onclick="switchLectureTab('notes')">Notes</button>
        <button id="tab-dppnotes" onclick="switchLectureTab('dppnotes')">DPPs</button>
        <button id="tab-dpplecture" onclick="switchLectureTab('dpplecture')">DPP Lectures</button>
      </div>
      <div class="grid" id="lectureContent"></div>
    </div>

    <div id="telegramPopup" class="popup">
      <div class="popup-content">
        <span class="popup-close">√ó</span>
        <img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg" alt="Telegram Icon"
          class="telegram-icon">
        <h2>Join Our Telegram Channel!</h2>
        <p>To Get New Updates Fast !</p>
        <a href="https://t.me/pwXavengers" target="_blank" class="telegram-btn">Join Now</a>
      </div>
    </div>
  </div>

  <!-- Floating Telegram Button -->
  <div class="floating-telegram-btn">
    <a href="https://t.me/pwXavengers" target="_blank" class="telegram-float-link">
      <i class="fab fa-telegram-plane"></i>
    </a>
  </div>

  <!-- <script>
    // Secure Cookie System with HMAC Signing
    // This prevents users from extending cookie expiry through DevTools

    // Secret key for HMAC signing (must match the one in success.html)
    const HMAC_SECRET = 'pwavengers9936';

    // Secure Cookie Management
    class SecureCookie {
      static async generateHMACKey(secret) {
        const encoder = new TextEncoder();
        const keyData = encoder.encode(secret);
        return await crypto.subtle.importKey(
          'raw',
          keyData,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['sign', 'verify']
        );
      }

      static async verifySecureToken(token) {
        try {
          const [payloadB64, signatureB64] = token.split('.');
          if (!payloadB64 || !signatureB64) return null;

          const payloadStr = atob(payloadB64);
          const payload = JSON.parse(payloadStr);

          // Check expiration
          if (Date.now() > payload.exp) {
            console.log('Token expired:', new Date(payload.exp));
            return null;
          }

          // Verify signature
          const encoder = new TextEncoder();
          const payloadBytes = encoder.encode(payloadStr);
          const signatureBytes = new Uint8Array(atob(signatureB64).split('').map(c => c.charCodeAt(0)));

          const key = await this.generateHMACKey(HMAC_SECRET);
          const isValid = await crypto.subtle.verify('HMAC', key, signatureBytes, payloadBytes);

          if (!isValid) {
            console.log('Invalid token signature');
            return null;
          }

          return payload;
        } catch (error) {
          console.log('Token verification failed:', error);
          return null;
        }
      }
    }

    // Helper function to get cookie
    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
    }

    // Secure access validation
    (async function () {
      const secureToken = getCookie('pwavengers-key');

      if (!secureToken) {
        console.log('No secure token found, redirecting to key generation');
        window.location.replace('generate-key.html');
        return;
      }

      const payload = await SecureCookie.verifySecureToken(secureToken);

      if (!payload || payload.data !== 'success') {
        console.log('Invalid or expired secure token, redirecting to key generation');
        // Remove invalid token
        document.cookie = 'pwavengers-key=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Strict';
        window.location.replace('generate-key.html');
        return;
      }

      console.log('User has valid secure access to Website C');
      console.log('Token expires:', new Date(payload.exp));
    })();
  </script> -->

  <script>
    // CONSOLE
    const originalConsole = {
      log: console.log,
      warn: console.warn,
      error: console.error,
      info: console.info,
      debug: console.debug
    };

    originalConsole.log('%cüíÄ %cùïÄ‚Ñïùïä‚Ñôùîº‚ÑÇùïã ??',
      'font-size: 50px;',
      'color: #ff0000; font-size: 50px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);'
    );
    originalConsole.log('%cüòÇ %cùïÇùï™ùïí ùïÑùïöùïùùïñùïòùïí ùïÄùïüùï§ùï°ùïñùî†ùï• ùïÇùïíùï£ùïúùïñ ?',
      'font-size: 30px;',
      'color: #ff6b6b; font-size: 30px; font-weight: bold;'
    );
    originalConsole.log('%c‚úîÔ∏è %c‚Ñôùïíùïïùïôùïíùïö ùïÇùïíùï£ùïùùï† ‚ÑÇùïôùï¶ùï°ùî†ùïôùïíùï° !',
      'font-size: 30px;',
      'color: #ff9500; font-size: 30px; font-weight: bold;'
    );

    console.log = function () { };
    console.warn = function () { };
    console.error = function () { };
    console.info = function () { };
    console.debug = function () { };
    console.trace = function () { };
    console.table = function () { };
    console.group = function () { };
    console.groupEnd = function () { };
    console.time = function () { };
    console.timeEnd = function () { };
    console.count = function () { };
    console.assert = function () { };
    console.dir = function () { };
    console.dirxml = function () { };
    console.profile = function () { };
    console.profileEnd = function () { };
    console.timeStamp = function () { };
    console.clear = function () { };
  </script>
  <script>
    const redirectUrl = 'https://t.me/pwXavengers';
    const checkInterval = 500;
    let hasRedirected = false;

    function isDevToolsOpen() {
      // Higher threshold to avoid false positives from browser UI or extensions
      const widthThreshold = window.outerWidth - window.innerWidth > 800;
      const heightThreshold = window.outerHeight - window.innerHeight > 800;
      return widthThreshold || heightThreshold;
    }

    function checkDevTools() {
      if (isDevToolsOpen() && !hasRedirected) {
        hasRedirected = true;
        window.location.replace(redirectUrl);
      }
    }

    // Delay initial check to allow window sizes to stabilize
    setTimeout(() => {
      checkDevTools();
      // Start periodic checks after initial delay
      setInterval(checkDevTools, checkInterval);
    }, 1000);
  </script>

  <script>
    // Popup functionality
    document.addEventListener('DOMContentLoaded', () => {
      const popup = document.getElementById('telegramPopup');
      const closeBtn = document.querySelector('.popup-close');
      const exploreBtn = document.getElementById('explore-btn');
      const loadingOverlay = document.getElementById('loading-overlay');

      if (popup && closeBtn) {
        popup.style.zIndex = '1000'; // Ensure popup is on top

        // Show popup on page load
        popup.style.display = 'flex';



        // Close popup when close button is clicked
        closeBtn.addEventListener('click', () => {
          popup.style.display = 'none';
        });

        // Close popup when clicking outside the popup content
        window.addEventListener('click', (event) => {
          if (event.target === popup) {
            popup.style.display = 'none';
          }
        });
      }
    });
  </script>

  <script>
    const API_BASE = "https://pwxavengers-proxy.pw-avengers.workers.dev";
    const loadingOverlay = document.getElementById("loadingOverlay");
    const main = document.getElementById("main");
    const subjectsDiv = document.getElementById("subjects");
    const chaptersDiv = document.getElementById("chapters");
    const backBtn = document.getElementById("backBtn");
    const searchInput = document.getElementById("searchInput");
    const todayClassesDiv = document.getElementById("todayClasses");

    let viewStack = [];
    let allBatches = [];
    let chapterPage = 1;
    let chapterTotal = Infinity;
    let chapterLoading = false;
    let currentBatchId = "";
    let currentSubjectSlug = "";
    let lecturePage = 1;
    let lectureTotal = Infinity;
    let lectureLoading = false;
    let currentTopicId = "";
    let currentContentType = "vidoes";
    let currentSubjectId = "";
    let currentPage = 1;
    let isLoading = false;
    let hasMore = true;
    let currentQuery = "";

    // Favorite batch functionality (matching test.html)
    function getFavoriteBatches() {
      const stored = localStorage.getItem("favoriteBatches");
      return stored ? JSON.parse(stored) : [];
    }

    function isFavoriteBatch(batchId) {
      return getFavoriteBatches().includes(batchId);
    }

    function toggleFavoriteBatch(batchId) {
      const favs = getFavoriteBatches();
      const index = favs.indexOf(batchId);
      if (index > -1) {
        favs.splice(index, 1);
      } else {
        favs.push(batchId);
      }
      localStorage.setItem("favoriteBatches", JSON.stringify(favs));
    }

    function sortAndRenderBatches() {
      // Separate favorite and non-favorite batches
      const favoriteBatches = [];
      const nonFavoriteBatches = [];
      const favorites = getFavoriteBatches();
      
      console.log('üî• Sorting batches. Current favorites:', favorites);
      console.log('üî• All batches before sorting:', allBatches.map(b => ({ id: b.batchId, name: b.name })));
      
      allBatches.forEach(batch => {
        if (isFavoriteBatch(batch.batchId)) {
          favoriteBatches.push(batch);
        } else {
          nonFavoriteBatches.push(batch);
        }
      });
      
      console.log('üî• Favorite batches found:', favoriteBatches.map(b => ({ id: b.batchId, name: b.name })));
      console.log('üî• Non-favorite batches:', nonFavoriteBatches.map(b => ({ id: b.batchId, name: b.name })));
      
      // Sort non-favorite batches by date (newest first)
      nonFavoriteBatches.sort((a, b) => {
        const dateA = new Date(a.startDate || 0);
        const dateB = new Date(b.startDate || 0);
        return dateB - dateA; // Newest first (descending order)
      });
      
      console.log('üî• Non-favorite batches sorted by date:', nonFavoriteBatches.map(b => ({ id: b.batchId, name: b.name, date: b.startDate })));
      
      // Combine favorite batches (unchanged order) with date-sorted non-favorite batches
      const sortedBatches = [...favoriteBatches, ...nonFavoriteBatches];
      console.log('üî• Final sorted batches:', sortedBatches.map(b => ({ id: b.batchId, name: b.name })));

      renderBatches(sortedBatches);
    }

    // Modern Notification Function
    function showNotification(message, type = 'warning') {
      const popup = document.getElementById('notificationPopup');
      const messageEl = popup.querySelector('.notification-message');
      const iconEl = popup.querySelector('.notification-icon');

      // Set message
      messageEl.textContent = message;

      // Set icon based on type
      if (type === 'warning') {
        iconEl.className = 'fas fa-exclamation-triangle notification-icon';
      } else if (type === 'error') {
        iconEl.className = 'fas fa-times-circle notification-icon';
      } else if (type === 'success') {
        iconEl.className = 'fas fa-check-circle notification-icon';
      }

      // Show popup
      popup.style.display = 'block';
      popup.classList.remove('fade-out');

      // Auto hide after 3 seconds
      setTimeout(() => {
        popup.classList.add('fade-out');
        setTimeout(() => {
          popup.style.display = 'none';
        }, 300);
      }, 3000);
    }

    function showBatchesView() {
      // ‚úÖ No pushView(). This function now ONLY renders the batches view.
      clearAll();
      main.style.display = "grid"; // Ensure the main grid is visible
      // Live Classes should only appear when a batch is opened, not on homepage
      searchInput.style.display = "block"; // Show search input on homepage
      backBtn.style.display = "none"; // Hide back button on homepage

      currentPage = 1;
      currentQuery = "";
      hasMore = true;
      allBatches = [];
      loadBatches({ reset: true });
    }


    function showLoader(show) {
      loadingOverlay.style.display = show ? "flex" : "none";
    }
    function show(el) {
      clearAll();
      el.style.display = "block";
    }
    function clearAll() {
      const ids = ["main", "subjects", "chaptersDiv", "lectureSection", "todayWrapper"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = "none";
      });

      const backBtn = document.getElementById("backBtn");
      if (backBtn) {
        backBtn.style.display = "block";
        backBtn.onclick = handleBackNavigation;
      }

      // üîª Hide load more batches button when leaving the main batches page
      const loadMoreBtnWrapper = document.getElementById("loadMoreBatchesWrapper");
      if (loadMoreBtnWrapper) loadMoreBtnWrapper.style.display = "none";
    }




    function handleBackNavigation() {
      // Clear current view
      clearAll();

      // Remove URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const batchId = urlParams.get("batch");
      const subjectSlug = urlParams.get("subject");
      const topicId = urlParams.get("topic");

      if (batchId && subjectSlug && topicId) {
        // If we were in lecture view, go back to chapters view
        history.pushState({}, '', `?batch=${batchId}&subject=${subjectSlug}`);
        loadChapters(batchId, subjectSlug);
      } else if (batchId && subjectSlug) {
        // If we were in chapters view, go back to subjects view
        history.pushState({}, '', `?batch=${batchId}`);
        loadSubjects(batchId);
      } else if (batchId) {
        // If we were in subjects view, go back to batches view
        history.pushState({}, '', window.location.pathname);
        showBatchesView();
      } else {
        // If we were in batches view, go back to batches view (shouldn't happen with back button)
        showBatchesView();
      }
    }

    function pushView(fn, state = {}) {
      viewStack.push(fn);
      // Don't push state to history since we are using URL parameters for navigation
    }


    function show(div) {
      clearAll();
      div.style.display = div.id === "lectureSection" ? "block" : "grid";
    }

    function appendCard(container, title, image, batchId, onClick) {
      const div = document.createElement("div");
      div.className = "card";

      // Check if this batch is bookmarked (keeping original terminology)
      const isBookmarked = isFavoriteBatch(batchId);

      div.innerHTML = `
        ${image ? `<img src="${image}" alt="${title}" />` : ""}
        <div class="bookmark-icon ${isBookmarked ? 'bookmarked' : ''}" data-batch-id="${batchId}">
          <i class="fas fa-bookmark"></i>
        </div>
        <div class="card-title">${title}</div>
        <button class="explore-button" onclick="event.stopPropagation();">EXPLORE</button>
      `;

      // Add click handler only to the explore button
      const exploreBtn = div.querySelector('.explore-button');
      exploreBtn.onclick = (event) => {
        event.stopPropagation();
        onClick();
      };

      // Add click handler for bookmark icon
      const bookmarkIcon = div.querySelector('.bookmark-icon');
      bookmarkIcon.onclick = (event) => {
        event.stopPropagation();
        toggleFavoriteBatch(batchId);
        // Re-render the entire list to show the favorited item at the top
        sortAndRenderBatches();
      };

      container.appendChild(div);
    }

    // BATCH FILTERING NOW HANDLED SERVER-SIDE
    // No need for client-side filtering - server returns only allowed batches

    async function loadBatches({ reset = false } = {}) {
      if (isLoading || (!hasMore && !reset)) return;
      isLoading = true;
      showLoader(true);
  
  // Get reference to the load more button and wrapper
  const loadMoreBtn = document.getElementById("loadMoreBatchesBtn");
  const loadMoreBtnWrapper = document.getElementById("loadMoreBatchesWrapper");
  
  if (loadMoreBtn) loadMoreBtn.disabled = true;
  
  if (reset) {
    currentPage = 1;
    allBatches = [];
    main.innerHTML = "";
    hasMore = true;
  }
  
  main.style.display = "grid";
  
  try {
    let favBatches = [];
    const favorites = getFavoriteBatches();
    
    // --- PRIORITY LOADING: Start ---
    // On the very first load (when reset is true) and if not searching,
    // fetch all favorited batches first.
    if (reset && favorites.length > 0 && !currentQuery) {
      try {
        console.log('üî• Fetching favorite batches:', favorites);
        const favRes = await fetch(`${API_BASE}/api/batches/by-ids?ids=${favorites.join(',')}`);
        const favData = await favRes.json();
        console.log('üî• Favorite batches response:', favData);
        if (favData.success && favData.batches) {
          // Map the favorite batches to our standard card format
          favBatches = favData.batches.map(b => ({
            batchId: b._id,
            name: b.name,
            byName: b.byName,
            image: b.previewImage || 'https://placehold.co/600x340/1a1a1a/ffffff?text=No+Image',
            language: b.language,
            exam: b.exam,
            startDate: b.start_date,
          }));
          console.log('üî• Mapped favorite batches:', favBatches);
        }
      } catch (favErr) {
        console.error("Failed to load favorite batches:", favErr);
        // Continue execution even if favorites fail to load
      }
    }
    // --- PRIORITY LOADING: End ---
    
    // Use limit of 12 batches per page (like in TEST.HTML)
    const query = currentQuery ? `&q=${encodeURIComponent(currentQuery)}` : "";
    const res = await fetch(`${API_BASE}/api/batches?page=${currentPage}&limit=15${query}`);
    const data = await res.json();
    
    let newBatches = [];
    if (data.success && data.batches && data.batches.length > 0) {
      newBatches = data.batches.map(b => ({
        batchId: b._id,
        name: b.name,
        byName: b.byName,
        image: b.previewImage || 'https://placehold.co/600x340/1a1a1a/ffffff?text=No+Image',
        language: b.language,
        exam: b.exam,
        startDate: b.start_date,
      }));
    }
    
    // Combine and de-duplicate batches
    const combinedBatches = [...favBatches, ...allBatches, ...newBatches];
    const uniqueBatchesMap = new Map(combinedBatches.map(batch => [batch.batchId, batch]));
    allBatches = Array.from(uniqueBatchesMap.values());
    
    // Sort and render batches (favorites first)
    sortAndRenderBatches();
    
    // Update pagination state
    if (newBatches.length === 0 || (data.totalPages && currentPage >= data.totalPages)) {
      hasMore = false;
      if (loadMoreBtnWrapper) loadMoreBtnWrapper.style.display = "none";
    } else {
      currentPage++;
      if (loadMoreBtnWrapper) loadMoreBtnWrapper.style.display = "block";
    }
    
    if (allBatches.length === 0) {
      renderNoResults();
    }
    
  } catch (err) {
    console.error(" Failed to load batches:", err);
  } finally {
    isLoading = false;
    showLoader(false);
    if (loadMoreBtn) loadMoreBtn.disabled = false;
  }
}

    function renderBatches(batches, { append = false } = {}) {
      if (!append) main.innerHTML = "";

      todayWrapper.style.display = "none";
      backBtn.style.display = "none";
      searchInput.style.display = "block";
  
      // Show/hide load more button based on hasMore state
      const loadMoreBtnWrapper = document.getElementById("loadMoreBatchesWrapper");
      if (loadMoreBtnWrapper) {
        loadMoreBtnWrapper.style.display = hasMore ? "block" : "none";
      }

      batches.forEach(batch => {
        appendCard(main, batch.name, batch.image, batch.batchId, () => {
          currentBatchName = batch.name;
          loadSubjects(batch.batchId);
        });
      });
    }

    function renderNoResults() {
      main.innerHTML = `
    <div style="text-align:center; color:#666; padding:2rem;">
      <p> No batches found.</p>
      <p>üîç No batches found.</p>
    </div>
  `;
    }

    window.addEventListener("scroll", () => {
      const nearBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 100;

      const isBatchesView =
        main.style.display !== "none" &&
        subjectsDiv.style.display === "none" &&
        chaptersDiv.style.display === "none" &&
        document.getElementById("lectureSection").style.display === "none" &&
        document.getElementById("todayWrapper").style.display === "none";

      if (nearBottom && isBatchesView && !isLoading) {
        loadBatches();
      }
    });
    ;




    // üîç Search input listener
    searchInput.addEventListener("input", debounce(() => {
      currentQuery = searchInput.value.trim();
      loadBatches({ reset: true });
    }, 300));
    
    // üéØ Load More Arenas button listener
    const loadMoreBtn = document.getElementById("loadMoreBatchesBtn");
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener("click", () => {
        loadBatches();
      });
    }

    // Utility: debounce
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    }


    async function loadSubjects(batchId) {
      // Update URL to reflect current view
      history.pushState({}, '', `?batch=${batchId}`);
      show(subjectsDiv);
      backBtn.style.display = "block";

      subjectsDiv.innerHTML = "";
      searchInput.style.display = "none";
      showLoader(true);
      try {
        const res = await fetch(`${API_BASE}/api/batch/${encodeURIComponent(batchId)}`);
        const json = await res.json();
        const subs = (json.data && json.data.subjects) || [];

        // If no subjects, show message
        if (subs.length === 0) {
          subjectsDiv.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-folder-times" style="margin-right: 8px; opacity: 0.7;"></i>Failed to load batch subjects.</div>';
          showLoader(false);
          return;
        }

        // 1. Define appendCard FIRST
        function appendCard(container, sub, onClick) {
          const subjectName = sub.subject;
          const iconUrl = sub.imageId ? `${sub.imageId.baseUrl}${sub.imageId.key}` : '';
          const lectureCount = sub.lectureCount || 0;
          const chapterCount = sub.tagCount || 0;

          const teacher = sub.teacherIds?.[0];
          const teacherImg = teacher?.imageId
            ? `${teacher.imageId.baseUrl}${teacher.imageId.key}`
            : '';
          const teacherName = teacher ? `${teacher.firstName} ${teacher.lastName}` : 'TBA';

          const card = document.createElement('div');
          card.className = 'subject-card';
          card.onclick = onClick;

          card.innerHTML = `
    <div class="card-header">
      <img class="subject-icon" src="${iconUrl}" alt="${subjectName}" />
      <div class="subject-title">${subjectName}</div>
    </div>
    <div class="card-details">
      <div>üé• <strong>${lectureCount}</strong> Lectures</div>
      <div>üìö <strong>${chapterCount}</strong> Chapters</div>
    </div>
    <div class="teacher-info">
      <img class="teacher-img" src="${teacherImg}" alt="${teacherName}" />
      <div class="teacher-name">${teacherName}</div>
    </div>
  `;

          container.appendChild(card);
        }

        // 2. Then call it inside your loop
        subs.forEach(sub => {
          appendCard(subjectsDiv, sub, () => {
            chapterPage = 1;
            chapterLoading = false;
            currentSubjectId = sub.subjectId || sub._id;
            currentSubjectName = sub.subject;
            loadChapters(batchId, sub.slug);
          });
        });

        const todayRes = await fetch(`${API_BASE}/api/batch/${encodeURIComponent(batchId)}/todays-schedule`);
        const todayJson = await todayRes.json();
        // Filter today's classes to show only live classes
        // Filter today's classes to show only live classes
        const todayClasses = (todayJson.data || []).filter(cls => cls.lectureType === "LIVE" || cls.lectureType === "RECORDED" || cls.lectureType === "CANCELLED");
        const todayWrapper = document.getElementById("todayWrapper");
        const todayScrollContainer = document.getElementById("todayScrollContainer");

        if (document.getElementById("subjects").style.display !== "none") {
          todayWrapper.style.display = "block";
        }


        // If no live classes, show message
        if (todayClasses.length === 0) {
          todayScrollContainer.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-calendar-times" style="margin-right: 8px; opacity: 0.7;"></i>No live classes today.</div>';
        } else {
          todayScrollContainer.innerHTML = ""; // Clear previous content
        }

        // Loop through today's classes
        todayClasses.forEach(cls => {
          const title = cls.topic || "Untitled";
          const subject = cls.subjectId?.name || "Unknown Subject";
          const time = new Date(cls.startTime).toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
          const chapter = cls.tags?.[0]?.name || "General";
          const tagLabel = cls.tag || "Upcoming";

          const statusColor = tagLabel === "Live"
            ? "#00FF88"  // Bright green for live
            : tagLabel === "Ended"
              ? "#FF4444"  // Red for ended
              : "#2196F3"; // Blue for upcoming

          const card = document.createElement("div");
          card.className = "today-card";

          // Required for horizontal scroll layout
          card.style.width = "260px";
          card.style.flex = "0 0 auto";

          card.innerHTML = `
    <div style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 5px;">${subject}</div>
    <div class="today-card-title">${title}</div>
    <div style="font-size: 0.85rem; margin-top: 5px;">üïí ${time} IST</div>
    <div style="margin-top: 5px; font-size: 0.8rem; background: var(--bg-tertiary); padding: 4px 8px; border-radius: 6px; display: inline-block;">${chapter}</div>
    <div class="status-tag" style="position: absolute; top: 10px; right: 10px; background: ${statusColor}; color: black; font-weight: bold; font-size: 0.75rem; padding: 2px 6px; border-radius: 6px;">${tagLabel}</div>
    <div class="today-play-button">
          <i class="fas fa-play"></i>
        </div>
  `;

          card.onclick = async () => {
            if (tagLabel === "Upcoming") {
              showNotification("Class not started yet. Please wait.", 'warning');
              return;
            }

            const batchId = cls.batch?._id || cls.batchId?._id || cls.batchId; // support for both structures
            const scheduleId = cls._id;

            if (!batchId || !scheduleId) {
              alert("Invalid class identifiers.");
              return;
            }

            showLoader(true);

            try {
              const res = await fetch(`${API_BASE}/api/url?batch_id=${batchId}&schedule_id=${scheduleId}`);
              const data = await res.json();

              if (data.success && data.signed_url && data.video_id) {
                const urlParams = new URLSearchParams({
                  encrypted: data.signed_url,
                  iv: data.video_id
                });
                if (data.pally_data && data.pally_iv) {
                  urlParams.append('pally_data', data.pally_data);
                  urlParams.append('pally_iv', data.pally_iv);
                }
                window.location.href = `player?${urlParams.toString()}`;
              } else {
                alert("‚ö†Ô∏è Failed to get live stream URL.");
              }
            } catch (err) {
              console.error("Live stream fetch error:", err);
              alert("‚ö†Ô∏è Error getting live stream URL.");
            } finally {
              showLoader(false);
            }
          };


          todayScrollContainer.appendChild(card);
        });
      } catch (err) {
        console.error("Failed to load subjects or todayclass:", err);
      } finally {
        showLoader(false);
      }
    }

    async function loadChapters(batchId, subjectSlug) {
      const chaptersDiv = document.getElementById("chaptersDiv");
      const oldWrapper = document.getElementById("chapterLoadMoreWrapper");
      if (oldWrapper) oldWrapper.remove();

      if (chapterLoading) return;

      // Update URL to reflect current view
      history.pushState({}, '', `?batch=${batchId}&subject=${subjectSlug}`);
      chaptersDiv.innerHTML = "";
      clearAll();
      document.getElementById("subjects").style.display = "none";
      searchInput.style.display = "none"; // Hide search input when viewing chapters

      chapterLoading = true;
      showLoader(true);

      currentBatchId = batchId;
      currentSubjectSlug = subjectSlug;

      try {
        const res = await fetch(`${API_BASE}/api/batch/${batchId}/subject/${subjectSlug}/topics`);
        const result = await res.json();

        const chapters = result.data || [];

        if (chapters.length === 0) {
          chaptersDiv.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-book-open" style="margin-right: 8px; opacity: 0.7;"></i>No chapters found.</div>';
        } else {
          chapters.forEach(ch => {
            const card = document.createElement("div");
            card.className = "chapter-card";
            card.innerHTML = `
          <div class="chapter-title">${ch.name}</div>
          <div class="chapter-meta">
            <div><i class="fas fa-video"></i> ${ch.lectureVideos || 0} Lectures</div>
            <div><i class="fas fa-file-alt"></i> ${ch.notes || 0} Notes</div>
            <div><i class="fas fa-book"></i> ${ch.exercises || 0} DPPs</div>
          </div>
        `;
            card.addEventListener("click", () => {
              if (!ch._id) {
                alert("Chapter ID missing. Cannot load lectures.");
                return;
              }
              pushView(() => loadChapters(batchId, subjectSlug));
              currentTopicName = ch.name;
              loadLecturesContent(batchId, subjectSlug, ch._id);
            });

            chaptersDiv.appendChild(card);
          });
        }

      } catch (err) {
        console.error("Failed to load chapters:", err);
        const errorMsg = document.createElement("div");
        errorMsg.className = "error-state";
        errorMsg.innerText = "Failed to load chapters. Please try again.";
        chaptersDiv.appendChild(errorMsg);
      } finally {
        showLoader(false);
        show(chaptersDiv);
        chapterLoading = false;
      }
    }

    async function loadLecturesContent(batchId, subjectSlug, topicId, contentType = "vidoes") {
      if (lectureLoading) return;
      lectureLoading = true;

      history.pushState({}, '', `?batch=${batchId}&subject=${subjectSlug}&topic=${topicId}&type=${contentType}`);
      document.getElementById("lectureContent").innerHTML = "";
      searchInput.style.display = "none"; // Hide search input when viewing lectures

      show(document.getElementById("lectureSection"));

      // Set default active tab based on content type
      const tabMap = {
        "vidoes": "lectures",
        "notes": "notes",
        "DppNotes": "dppnotes",
        "DppVideos": "dpplecture"
      };

      const activeTab = tabMap[contentType] || "lectures";

      // Remove active class from all tabs
      ["lectures", "notes", "dppnotes", "dpplecture"].forEach(t => {
        document.getElementById("tab-" + t).classList.remove("active");
      });

      // Set the appropriate tab as active
      document.getElementById("tab-" + activeTab).classList.add("active");

      showLoader(true);

      currentBatchId = batchId;
      currentSubjectSlug = subjectSlug;
      currentTopicId = topicId;
      currentContentType = contentType;

      const url = `${API_BASE}/api/batch/${batchId}/subject/${subjectSlug}/topic/${topicId}/all-contents?type=${contentType}`;

      try {
        const res = await fetch(url);
        const data = await res.json();
        const items = data.data || [];

        const lectureContent = document.getElementById("lectureContent");
        if (items.length === 0) {
          lectureContent.innerHTML = `<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-folder-open" style="margin-right: 8px; opacity: 0.7;"></i>No content found.</div>`;
          return;
        }

        // Process items while preserving parent scheduleId for homework items
        let processedItems = [];
        items.forEach(item => {
          if (item.homeworkIds && item.homeworkIds.length > 0) {
            // For each homework item, preserve the parent item's _id as scheduleId
            item.homeworkIds.forEach(hwItem => {
              processedItems.push({
                ...hwItem,
                scheduleId: item._id  // Parent item's _id is the scheduleId
              });
            });
          } else {
            processedItems.push({
              ...item,
              scheduleId: item._id
            });
          }
        });

        processedItems.forEach(item => {
          const div = document.createElement("div");
          div.className = "card";

          if (contentType === "notes" || contentType === "DppNotes") {
            let topicTitle = "Untitled Note";
            if (item.topic) {
              topicTitle = item.topic;
            } else if (item.homeworkIds?.[0]?.topic) {
              topicTitle = item.homeworkIds[0].topic;
            }
            const scheduleId = item.scheduleId; // Use the preserved scheduleId
            const isNote = contentType === "notes";
            const cardClass = isNote ? "note-card" : "dpp-card";
            const iconClass = isNote ? "note-icon" : "dpp-icon";
            const contentClass = isNote ? "note-content" : "dpp-content";
            const titleClass = isNote ? "note-title" : "dpp-title";
            const labelClass = isNote ? "note-label" : "dpp-label";
            const arrowClass = isNote ? "note-arrow" : "dpp-arrow";
            const iconEmoji = isNote ? "üìù" : "üìã";
            const labelText = isNote ? "NOTE" : "DPP";

            div.className = cardClass;
            div.innerHTML = `
    <div class="${contentClass === "note-content" ? "note-card-content" : "dpp-card-content"}">
      <div class="${iconClass}">
        ${iconEmoji}
      </div>
      <div class="${contentClass}">
        <div class="${titleClass}">${topicTitle}</div>
        <div class="${labelClass}">${labelText}</div>
      </div>
      <div class="${arrowClass}">
        >
      </div>
    </div>
  `;

            div.onclick = () => {
              fetchAndOpenAttachments(currentBatchId, currentSubjectSlug, scheduleId);
            };
          }
          else {
            const vid = item.videoDetails || item;
            const title = item.topic || vid.name || "Untitled Video";
            const image = vid.image || vid.thumbnail || "";
            const mediaUrl = vid.hls_url || item.url || "";
            const duration = vid.duration || "00:00:00";

            const startTime = new Date(item.startTime);
            const formattedDate = startTime.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric'
            });

            div.className = "lecture-card";
            div.innerHTML = `
    <div class="lecture-card-inner">
      <div class="lecture-thumbnail">
        <img src="${image}" alt="${title}" class="lecture-image" />
        <div class="video-watermark-top">
          <img src="https://www.pw.live/favicon.ico" alt="Logo" class="watermark-logo">
          @pwXavengers
        </div>
        <div class="lecture-play-button">
          <i class="fas fa-play"></i>
        </div>
      </div>
      <div class="lecture-info">
        <div class="lecture-meta">
          <span class="lecture-date">${formattedDate}</span>
          <span class="lecture-duration">${duration}</span>
        </div>
        <h3 class="lecture-title">${title}</h3>
      </div>
    </div>
  `;
            div.onclick = async () => {
              showLoader(true);
              try {
                let finalUrl = mediaUrl;
                const isYouTube = finalUrl && (finalUrl.includes('youtube.com') || finalUrl.includes('youtu.be'));
                if (isYouTube) return window.open(finalUrl, '_blank');

                const realVid = item.videoDetails || item;
                const params = new URLSearchParams({
                  batch: currentBatchId || 'Unknown Batch',
                  subject: currentSubjectSlug || 'Unknown Subject',
                  topic: currentTopicId || 'General',
                  title: item.topic || realVid.name || ''
                });

                const resp = await fetch(`${API_BASE}/api/video/stream-info?${params}`);
                const data = await resp.json();

                if (data.youtube && data.videoUrl) {
                  window.open(data.videoUrl, '_blank');
                  return;
                }

                if (data.success && data.signed_url && data.video_id) {
                  const urlParams = new URLSearchParams({
                    encrypted: data.signed_url,
                    iv: data.video_id
                  });
                  window.open(`player?${urlParams}`, '_blank');
                  return;
                }

                // Try the new API endpoint as a third option
                const fetchApi1 = async () => {
                  // First API endpoint (existing)
                  const scheduleId = item._id;
                  const res = await fetch(`${API_BASE}/api/url?batch_id=${currentBatchId}&schedule_id=${scheduleId}`);
                  const altData = await res.json();

                  if (altData.success && altData.signed_url && altData.video_id) {
                    const urlParams = new URLSearchParams({
                      encrypted: altData.signed_url,
                      iv: altData.video_id
                    });
                    if (altData.pally_data && altData.pally_iv) {
                      urlParams.append('pally_data', altData.pally_data);
                      urlParams.append('pally_iv', altData.pally_iv);
                    }
                    return { type: 'redirect', url: `player?${urlParams.toString()}` };
                  }
                  throw new Error('API 1 did not provide a valid video URL.');
                };

                const fetchApi2 = async () => {
                  // Second API endpoint (existing)
                  const resp = await fetch(`${API_BASE}/api/video/stream-info?${params}`);
                  const data = await resp.json();

                  if (data.youtube && data.videoUrl) {
                    return { type: 'open', url: data.videoUrl };
                  }

                  if (data.success && data.signed_url && data.video_id) {
                    const urlParams = new URLSearchParams({
                      encrypted: data.signed_url,
                      iv: data.video_id
                    });
                    return { type: 'open', url: `player?${urlParams}` };
                  }
                  throw new Error('API 2 did not provide a valid video URL.');
                };

                const fetchApi3 = async () => {
                  // Third API endpoint (new) - using our proxy
                  const scheduleId = item._id;
                  const res = await fetch(`${API_BASE}/api/video-data?batchId=${currentBatchId}&scheduleId=${scheduleId}`);
                  const responseJson = await res.json();

                  if (responseJson.success && responseJson.data && responseJson.iv) {
                    const urlParams = new URLSearchParams({
                      data: responseJson.data,
                      iv: responseJson.iv
                    });
                    return { type: 'redirect', url: `player?${urlParams}` };
                  }
                  throw new Error('API 3 did not provide valid video data.');
                };

                const fetchApi4 = async () => {
                  // Fourth API endpoint (new) - using our proxy
                  const scheduleId = item._id;
                  const res = await fetch(`${API_BASE}/api/video-data-alt?batchId=${currentBatchId}&scheduleId=${scheduleId}`);
                  const responseJson = await res.json();

                  if (responseJson.success && responseJson.data && responseJson.iv) {
                    const urlParams = new URLSearchParams({
                      data: responseJson.data,
                      iv: responseJson.iv
                    });
                    return { type: 'redirect', url: `player?${urlParams}` };
                  }
                  throw new Error('API 4 did not provide valid video data.');
                };

                // Run all API calls in parallel and get the first success
                try {
                  const result = await Promise.any([
                    fetchApi1(),
                    fetchApi2(),
                    fetchApi3(),
                    fetchApi4()
                  ]);

                  // Act on the first successful result
                  if (result.type === 'open') {
                    window.open(result.url, '_blank');
                    showLoader(false);
                  } else if (result.type === 'redirect') {
                    window.location.href = result.url;
                  }
                } catch (error) {
                  // This block executes only if ALL promises fail
                  console.error("All video sources failed to load:", error);
                  alert("‚ö†Ô∏è Server Issue....");
                }
              } catch (err) {
                console.error("Video load failed:", err);
                alert("‚ö†Ô∏è Video failed to load...");
              } finally {
                showLoader(false);
              }
            };
          }
          lectureContent.appendChild(div);
        });
      } catch (err) {
        console.error("Failed to load content:", err);
      } finally {
        lectureLoading = false;
        showLoader(false);
      }
    }
    async function fetchAndOpenAttachments(batchId, subjectSlug, scheduleId) {
      try {
        showLoader(true);
        const res = await fetch(`${API_BASE}/api/batch/${batchId}/subject/${subjectSlug}/schedule/${scheduleId}/content`);
        const data = await res.json();

        if (!data.data) {
          alert("No content found.");
          return;
        }

        // Handle single object response (not array)
        const scheduleData = data.data;
        const attachments = (scheduleData.homeworkIds || []).flatMap(hw =>
          (hw.attachmentIds || [])
        );

        if (!attachments.length) {
          alert("No attachments found.");
          return;
        }

        attachments.forEach(att => {
          const fileUrl = `${att.baseUrl}${att.key}`;
          window.open(fileUrl, '_blank');
        });

      } catch (err) {
        console.error("Failed to fetch schedule content:", err);
        alert("Error loading attachments.");
      } finally {
        showLoader(false);
      }
    }

    function switchLectureTab(tab) {
      const typeMap = {
        lectures: "vidoes",
        notes: "notes",
        dppnotes: "DppNotes",
        dpplecture: "DppVideos"
      };

      currentContentType = typeMap[tab] || "vidoes";


      ["lectures", "notes", "dppnotes", "dpplecture"].forEach(t => {
        document.getElementById("tab-" + t).classList.remove("active");
      });
      document.getElementById("tab-" + tab).classList.add("active");

      loadLecturesContent(currentBatchId, currentSubjectSlug, currentTopicId, currentContentType);
    }

    backBtn.onclick = () => {
      history.back(); // ‚úÖ triggers popstate event
    };


    searchInput.addEventListener("input", () => {
      const keyword = searchInput.value.toLowerCase();
      const filtered = allBatches.filter(b => b.name.toLowerCase().includes(keyword));
      renderBatches(filtered);
    });

    // Disable right-click and DevTools
    document.addEventListener('contextmenu', event => event.preventDefault());
    document.addEventListener('keydown', function (event) {
      if (
        event.key === "F12" ||
        (event.ctrlKey && event.shiftKey && (event.key === 'I' || event.key === 'J')) ||
        (event.ctrlKey && event.key === 'U') ||
        (event.ctrlKey && event.shiftKey && event.key === 'C') ||
        (event.ctrlKey && event.key === 'A') ||
        (event.ctrlKey && event.key === 'S') ||
        (event.ctrlKey && event.key === 'P')
      ) {
        event.preventDefault();
      }
    });
    window.addEventListener("popstate", () => {
      if (viewStack.length > 0) {
        const restoreView = viewStack.pop(); // ‚úÖ Pop the function for the view we are returning TO.
        if (typeof restoreView === 'function') {
          restoreView(); // ‚úÖ Execute it.
        }
      }
    });
    document.addEventListener("DOMContentLoaded", () => {
      // Check URL parameters to restore the correct view on page load
      const urlParams = new URLSearchParams(window.location.search);
      const batchId = urlParams.get("batch");
      const subjectSlug = urlParams.get("subject");
      const topicId = urlParams.get("topic");
      const contentType = urlParams.get("type") || "vidoes";

      if (batchId && subjectSlug && topicId) {
        // If batch, subject, and topic are in URL, show lecture content view
        loadLecturesContent(batchId, subjectSlug, topicId, contentType);
      } else if (batchId && subjectSlug) {
        // If both batch and subject are in URL, show chapters view
        loadChapters(batchId, subjectSlug);
      } else if (batchId) {
        // If only batch is in URL, show subjects view
        loadSubjects(batchId);
      } else {
        // Otherwise, show batches view (default)
        showBatchesView();
      }
    });


  </script>
</body>

</html>