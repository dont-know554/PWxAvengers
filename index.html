<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;500;600;700&display=swap"
    rel="stylesheet" />
  <link rel="icon" type="image/png" sizes="any" href="https://www.pw.live/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <title>PW x AVENGERS</title>
  <!-- <script disable-devtool-auto="true" src="https://cdn.jsdelivr.net/npm/disable-devtool" disable-select="true"
    disable-copy="true" disable-cut="true" disable-paste="false"></script> -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Cloudflare Web Analytics -->
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "6aeea0aeb5c54e3eac0fc4f0db759346"}'></script><!-- End Cloudflare Web Analytics -->
</head>

<body>
  <!-- Loading Spinner Overlay -->
  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <p class="loading-text">Loading...</p>
  </div>

  <!-- Modern Notification Popup -->
  <div id="notificationPopup" class="notification-popup" style="display: none;">
    <div class="notification-content">
      <i class="fas fa-exclamation-triangle notification-icon"></i>
      <span class="notification-message"></span>
    </div>
  </div>

  <div class="container">
    <header class="top-bar">
      <h1 class="title">PW<i id="header-icon" class="fa-solid fa-xmark"></i>AVENGERS</h1>
    </header>

    <input type="text" id="searchInput" placeholder="🔍 Enter Batch name" />

    <div class="grid" id="main"></div>
    <div class="back-btn" id="backBtn" style="display:none;">← Back</div>

    <div class="today-classes-wrapper" id="todayWrapper" style="display: none;">
      <div class="today-classes-title">Live Classes</div>
      <div class="today-scroll-container" id="todayScrollContainer"></div>
    </div>


    <div id="subjects" class="subjects-container" style="display: none;"></div>
    <!-- Grid container for chapters -->
    <div id="chaptersDiv" class="card-grid" style="display: none;"></div>

    <!-- Load more trigger (outside grid) -->
    <div id="chapterLoadMoreWrapper" style="display: none;">
      <div id="loadMoreChapters" style="width: 100%; height: 1px;"></div>
    </div>


    <div style="text-align:center; margin-top: 20px; display:none;" id="chapterLoadMoreWrapper">
      <button id="chapterLoadMoreBtn" class="load-more-btn">
        Load More Chapters
      </button>
    </div>

    <div id="lectureSection" style="display:none;">
      <div class="lecture-tabs">
        <button id="tab-lectures" class="active" onclick="switchLectureTab('lectures')">Lectures</button>
        <button id="tab-notes" onclick="switchLectureTab('notes')">Notes</button>
        <button id="tab-dppnotes" onclick="switchLectureTab('dppnotes')">DPPs</button>
        <button id="tab-dpplecture" onclick="switchLectureTab('dpplecture')">DPP Lectures</button>
      </div>
      <div class="grid" id="lectureContent"></div>
    </div>

    <div id="telegramPopup" class="popup">
      <div class="popup-content">
        <span class="popup-close">×</span>
        <img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Telegram_logo.svg" alt="Telegram Icon"
          class="telegram-icon">
        <h2>Join Our Telegram Channel!</h2>
        <p>To Get New Updates Fast !</p>
        <a href="https://t.me/pwXavengers" target="_blank" class="telegram-btn">Join Now</a>
      </div>
    </div>
  </div>

  <!-- Floating Telegram Button -->
  <div class="floating-telegram-btn">
    <a href="https://t.me/pwXavengers" target="_blank" class="telegram-float-link">
      <i class="fab fa-telegram-plane"></i>
    </a>
  </div>

  <!-- <script>
    // Secure Cookie System with HMAC Signing
    // This prevents users from extending cookie expiry through DevTools

    // Secret key for HMAC signing (must match the one in success.html)
    const HMAC_SECRET = 'pwavengers9936';

    // Secure Cookie Management
    class SecureCookie {
      static async generateHMACKey(secret) {
        const encoder = new TextEncoder();
        const keyData = encoder.encode(secret);
        return await crypto.subtle.importKey(
          'raw',
          keyData,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['sign', 'verify']
        );
      }

      static async verifySecureToken(token) {
        try {
          const [payloadB64, signatureB64] = token.split('.');
          if (!payloadB64 || !signatureB64) return null;

          const payloadStr = atob(payloadB64);
          const payload = JSON.parse(payloadStr);

          // Check expiration
          if (Date.now() > payload.exp) {
            console.log('Token expired:', new Date(payload.exp));
            return null;
          }

          // Verify signature
          const encoder = new TextEncoder();
          const payloadBytes = encoder.encode(payloadStr);
          const signatureBytes = new Uint8Array(atob(signatureB64).split('').map(c => c.charCodeAt(0)));

          const key = await this.generateHMACKey(HMAC_SECRET);
          const isValid = await crypto.subtle.verify('HMAC', key, signatureBytes, payloadBytes);

          if (!isValid) {
            console.log('Invalid token signature');
            return null;
          }

          return payload;
        } catch (error) {
          console.log('Token verification failed:', error);
          return null;
        }
      }
    }

    // Helper function to get cookie
    function getCookie(name) {
      const value = `; ${document.cookie}`;
      const parts = value.split(`; ${name}=`);
      if (parts.length === 2) return parts.pop().split(';').shift();
    }

    // Secure access validation
    (async function () {
      const secureToken = getCookie('pwavengers-key');

      if (!secureToken) {
        console.log('No secure token found, redirecting to key generation');
        window.location.replace('generate-key.html');
        return;
      }

      const payload = await SecureCookie.verifySecureToken(secureToken);

      if (!payload || payload.data !== 'success') {
        console.log('Invalid or expired secure token, redirecting to key generation');
        // Remove invalid token
        document.cookie = 'pwavengers-key=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; SameSite=Strict';
        window.location.replace('generate-key.html');
        return;
      }

      console.log('User has valid secure access to Website C');
      console.log('Token expires:', new Date(payload.exp));
    })();
  </script> -->
<!-- 
  <script>
    // CONSOLE
    const originalConsole = {
      log: console.log,
      warn: console.warn,
      error: console.error,
      info: console.info,
      debug: console.debug
    };

    originalConsole.log('%c💀 %c𝕀ℕ𝕊ℙ𝔼ℂ𝕋 ??',
      'font-size: 50px;',
      'color: #ff0000; font-size: 50px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);'
    );
    originalConsole.log('%c😂 %c𝕂𝕪𝕒 𝕄𝕚𝕝𝕖𝕘𝕒 𝕀𝕟𝕤𝕡𝕖𝔠𝕥 𝕂𝕒𝕣𝕜𝕖 ?',
      'font-size: 30px;',
      'color: #ff6b6b; font-size: 30px; font-weight: bold;'
    );
    originalConsole.log('%c✔️ %cℙ𝕒𝕕𝕙𝕒𝕚 𝕂𝕒𝕣𝕝𝕠 ℂ𝕙𝕦𝕡𝔠𝕙𝕒𝕡 !',
      'font-size: 30px;',
      'color: #ff9500; font-size: 30px; font-weight: bold;'
    );

    console.log = function () { };
    console.warn = function () { };
    console.error = function () { };
    console.info = function () { };
    console.debug = function () { };
    console.trace = function () { };
    console.table = function () { };
    console.group = function () { };
    console.groupEnd = function () { };
    console.time = function () { };
    console.timeEnd = function () { };
    console.count = function () { };
    console.assert = function () { };
    console.dir = function () { };
    console.dirxml = function () { };
    console.profile = function () { };
    console.profileEnd = function () { };
    console.timeStamp = function () { };
    console.clear = function () { };
  </script>
  <script>
    const redirectUrl = 'https://t.me/pwXavengers';
    const checkInterval = 500;
    let hasRedirected = false;

    function isDevToolsOpen() {
      // Higher threshold to avoid false positives from browser UI or extensions
      const widthThreshold = window.outerWidth - window.innerWidth > 800;
      const heightThreshold = window.outerHeight - window.innerHeight > 800;
      return widthThreshold || heightThreshold;
    }

    function checkDevTools() {
      if (isDevToolsOpen() && !hasRedirected) {
        hasRedirected = true;
        window.location.replace(redirectUrl);
      }
    }

    // Delay initial check to allow window sizes to stabilize
    setTimeout(() => {
      checkDevTools();
      // Start periodic checks after initial delay
      setInterval(checkDevTools, checkInterval);
    }, 1000);
  </script> -->

  <script>
    // Popup functionality
    document.addEventListener('DOMContentLoaded', () => {
      const popup = document.getElementById('telegramPopup');
      const closeBtn = document.querySelector('.popup-close');
      const exploreBtn = document.getElementById('explore-btn');
      const loadingOverlay = document.getElementById('loading-overlay');

      if (popup && closeBtn) {
        popup.style.zIndex = '1000'; // Ensure popup is on top

        // Show popup on page load
        popup.style.display = 'flex';



        // Close popup when close button is clicked
        closeBtn.addEventListener('click', () => {
          popup.style.display = 'none';
        });

        // Close popup when clicking outside the popup content
        window.addEventListener('click', (event) => {
          if (event.target === popup) {
            popup.style.display = 'none';
          }
        });
      }
    });
  </script>

  <script>
    const API_BASE = "https://secret-proxy.pw-avengers.workers.dev";
    const loadingOverlay = document.getElementById("loadingOverlay");
    const main = document.getElementById("main");
    const subjectsDiv = document.getElementById("subjects");
    const chaptersDiv = document.getElementById("chapters");
    const backBtn = document.getElementById("backBtn");
    const searchInput = document.getElementById("searchInput");
    const todayClassesDiv = document.getElementById("todayClasses");

    let viewStack = [];
    let allBatches = [];
    let chapterPage = 1;
    let chapterTotal = Infinity;
    let chapterLoading = false;
    let currentBatchId = "";
    let currentSubjectSlug = "";
    let lecturePage = 1;
    let lectureTotal = Infinity;
    let lectureLoading = false;
    let currentTopicId = "";
    let currentTagId = ""; // Actual tag ID for V3 API calls
    let currentContentType = "LECTURES";
    let currentTabType = "lectures"; // Track current tab for filtering
    let currentSubjectId = "";
    let currentPage = 1;
    let isLoading = false;
    let hasMore = true;
    let currentQuery = "";

    // Enhanced Favorite Batches functionality - stores both ID and name
    function getFavoriteBatches() {
      const stored = localStorage.getItem("favoriteBatches");
      return stored ? JSON.parse(stored) : [];
    }

    function isFavoriteBatch(batchId) {
      const favorites = getFavoriteBatches();
      return favorites.some(fav => fav.id === batchId);
    }

    function toggleFavoriteBatch(batchId, bookmarkIcon, batchName = null) {
      const favs = getFavoriteBatches();
      const index = favs.findIndex(fav => fav.id === batchId);
      
      if (index > -1) {
        // Remove from favorites
        favs.splice(index, 1);
        if (bookmarkIcon) bookmarkIcon.classList.remove('bookmarked');
        console.log('🗑️ Removed from favorites:', batchName || batchId);
      } else {
        // Add to favorites - need batch name for API calls
        if (!batchName) {
          // Find batch name from current allBatches
          const batch = allBatches.find(b => b.batchId === batchId);
          batchName = batch ? batch.name : 'Unknown';
        }
        favs.push({ id: batchId, name: batchName });
        if (bookmarkIcon) bookmarkIcon.classList.add('bookmarked');
        console.log('⭐ Added to favorites:', batchName);
      }
      
      localStorage.setItem("favoriteBatches", JSON.stringify(favs));
      console.log('💾 Updated favorites in localStorage:', favs);
      
      // Re-sort the batches list
      if (allBatches.length > 0) {
        sortAndRenderBatches();
      }
    }

    // Function to fetch favorite batches individually by name
    async function fetchFavoriteBatches() {
      const favorites = getFavoriteBatches();
      if (favorites.length === 0) return [];
      
      console.log('🔍 Fetching favorite batches:', favorites.map(f => f.name));
      const favoriteBatches = [];
      
      // Fetch each favorite batch individually
      for (const favorite of favorites) {
        try {
          const apiUrl = `${API_BASE}/batches/search?page=1&name=${encodeURIComponent(favorite.name)}`;
          console.log('📡 Fetching favorite batch:', favorite.name, 'from:', apiUrl);
          
          const res = await fetch(apiUrl);
          const data = await res.json();
          
          if (data.success && data.data) {
            // Find the exact batch by ID (in case multiple batches have similar names)
            const exactBatch = data.data.find(b => b._id === favorite.id);
            if (exactBatch) {
              favoriteBatches.push({
                name: exactBatch.name,
                image: exactBatch.previewImage?.key ? `https://static.pw.live/${exactBatch.previewImage.key}` : null,
                batchId: exactBatch._id,
                startDate: exactBatch.startDate,
                isFavorite: true // Mark as favorite for sorting
              });
              console.log('⭐ Found favorite batch:', exactBatch.name);
            } else {
              console.log('⚠️ Favorite batch not found by ID, trying first result:', favorite.name);
              // If exact ID not found, use first result (batch might have been updated)
              if (data.data.length > 0) {
                const firstBatch = data.data[0];
                favoriteBatches.push({
                  name: firstBatch.name,
                  image: firstBatch.previewImage?.key ? `https://static.pw.live/${firstBatch.previewImage.key}` : null,
                  batchId: firstBatch._id,
                  startDate: firstBatch.startDate,
                  isFavorite: true
                });
              }
            }
          }
        } catch (error) {
          console.error('❌ Error fetching favorite batch:', favorite.name, error);
        }
      }
      
      console.log('✅ Fetched favorite batches:', favoriteBatches.length);
      return favoriteBatches;
    }

    // Legacy function for backward compatibility
    function isBatchBookmarked(batchId) {
      return isFavoriteBatch(batchId);
    }

    function toggleBookmark(batchId, bookmarkIcon) {
      return toggleFavoriteBatch(batchId, bookmarkIcon);
    }

    function sortAndRenderBatches() {
      // Separate favorite and non-favorite batches
      const favoriteBatches = [];
      const nonFavoriteBatches = [];
      const favorites = getFavoriteBatches();
      
      console.log('🔥 Sorting batches. Current favorites:', favorites);
      console.log('🔥 All batches before sorting:', allBatches.map(b => ({ id: b.batchId, name: b.name })));
      
      allBatches.forEach(batch => {
        if (isFavoriteBatch(batch.batchId)) {
          favoriteBatches.push(batch);
        } else {
          nonFavoriteBatches.push(batch);
        }
      });
      
      console.log('🔥 Favorite batches found:', favoriteBatches.map(b => ({ id: b.batchId, name: b.name })));
      console.log('🔥 Non-favorite batches:', nonFavoriteBatches.map(b => ({ id: b.batchId, name: b.name })));
      
      // Sort non-favorite batches by date (newest first)
      nonFavoriteBatches.sort((a, b) => {
        const dateA = new Date(a.startDate || 0);
        const dateB = new Date(b.startDate || 0);
        return dateB - dateA; // Newest first (descending order)
      });
      
      console.log('🔥 Non-favorite batches sorted by date:', nonFavoriteBatches.map(b => ({ id: b.batchId, name: b.name, date: b.startDate })));
      
      // Combine favorite batches (unchanged order) with date-sorted non-favorite batches
      const sortedBatches = [...favoriteBatches, ...nonFavoriteBatches];
      console.log('🔥 Final sorted batches:', sortedBatches.map(b => ({ id: b.batchId, name: b.name })));

      renderBatches(sortedBatches);
    }

    // Modern Notification Function
    function showNotification(message, type = 'warning') {
      const popup = document.getElementById('notificationPopup');
      const messageEl = popup.querySelector('.notification-message');
      const iconEl = popup.querySelector('.notification-icon');

      // Set message
      messageEl.textContent = message;

      // Set icon based on type
      if (type === 'warning') {
        iconEl.className = 'fas fa-exclamation-triangle notification-icon';
      } else if (type === 'error') {
        iconEl.className = 'fas fa-times-circle notification-icon';
      } else if (type === 'success') {
        iconEl.className = 'fas fa-check-circle notification-icon';
      }

      // Show popup
      popup.style.display = 'block';
      popup.classList.remove('fade-out');

      // Auto hide after 3 seconds
      setTimeout(() => {
        popup.classList.add('fade-out');
        setTimeout(() => {
          popup.style.display = 'none';
        }, 300);
      }, 3000);
    }

    function showBatchesView() {
      // ✅ No pushView(). This function now ONLY renders the batches view.
      clearAll();
      main.style.display = "grid"; // Ensure the main grid is visible
      // Live Classes should only appear when a batch is opened, not on homepage
      searchInput.style.display = "block"; // Show search input on homepage
      backBtn.style.display = "none"; // Hide back button on homepage

      currentPage = 1;
      currentQuery = "";
      hasMore = true;
      allBatches = [];
      loadBatches({ reset: true });
    }


    function showLoader(show) {
      loadingOverlay.style.display = show ? "flex" : "none";
    }
    function show(el) {
      clearAll();
      el.style.display = "block";
    }
    function clearAll() {
      const ids = ["main", "subjects", "chaptersDiv", "lectureSection", "todayWrapper"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = "none";
      });

      const backBtn = document.getElementById("backBtn");
      if (backBtn) {
        backBtn.style.display = "block";
        backBtn.onclick = handleBackNavigation;
      }

      // 🔻 Hide load more batches button when leaving the main batches page
      const loadMoreBtnWrapper = document.getElementById("loadMoreBatchesWrapper");
      if (loadMoreBtnWrapper) loadMoreBtnWrapper.style.display = "none";
    }




    function handleBackNavigation() {
      // Clear current view
      clearAll();

      // Remove URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const batchId = urlParams.get("batch");
      const subjectSlug = urlParams.get("subject");
      const topicId = urlParams.get("topic");

      if (batchId && subjectSlug && topicId) {
        // If we were in lecture view, go back to chapters view
        history.pushState({}, '', `?batch=${batchId}&subject=${subjectSlug}`);
        loadChapters(batchId, subjectSlug);
      } else if (batchId && subjectSlug) {
        // If we were in chapters view, go back to subjects view
        history.pushState({}, '', `?batch=${batchId}`);
        loadSubjects(batchId);
      } else if (batchId) {
        // If we were in subjects view, go back to batches view
        history.pushState({}, '', window.location.pathname);
        showBatchesView();
      } else {
        // If we were in batches view, go back to batches view (shouldn't happen with back button)
        showBatchesView();
      }
    }

    function pushView(fn, state = {}) {
      viewStack.push(fn);
      // Don't push state to history since we are using URL parameters for navigation
    }


    function show(div) {
      clearAll();
      div.style.display = div.id === "lectureSection" ? "block" : "grid";
    }

    function appendCard(container, title, image, batchId, onClick) {
      const div = document.createElement("div");
      div.className = "card";

      // Check if this batch is bookmarked
      const isBookmarked = isBatchBookmarked(batchId);

      div.innerHTML = `
        ${image ? `<img src="${image}" alt="${title}" />` : ""}
        <div class="bookmark-icon ${isBookmarked ? 'bookmarked' : ''}" data-batch-id="${batchId}">
          <i class="fas fa-bookmark"></i>
        </div>
        <div class="card-title">${title}</div>
        <button class="explore-button" onclick="event.stopPropagation();">EXPLORE</button>
      `;

      // Add click handler only to the explore button
      const exploreBtn = div.querySelector('.explore-button');
      exploreBtn.onclick = (event) => {
        event.stopPropagation();
        onClick();
      };

      // Add click handler for bookmark icon
      const bookmarkIcon = div.querySelector('.bookmark-icon');
      bookmarkIcon.onclick = (event) => {
        event.stopPropagation();
        toggleBookmark(batchId, bookmarkIcon);
      };

      container.appendChild(div);
    }

    // 🎯 BATCH FILTERING NOW HANDLED SERVER-SIDE
    // No need for client-side filtering - server returns only allowed batches

    async function loadBatches({ reset = false } = {}) {
      if (isLoading || (!hasMore && !reset)) return;

      isLoading = true;

      if (reset) {
        currentPage = 1;
        allBatches = [];
        main.innerHTML = "";
        hasMore = true;
      }

      // Show main grid first, then loading overlay
      main.style.display = "grid";
      showLoader(true);

      try {
        let serverFilteredBatches = [];
        
        // 🎆 ENHANCED: Fetch favorites first on initial load or reset
        if (reset || currentPage === 1) {
          console.log('🔍 Fetching favorite batches first...');
          const favoriteBatches = await fetchFavoriteBatches();
          serverFilteredBatches = [...favoriteBatches];
          console.log('⭐ Added', favoriteBatches.length, 'favorite batches to results');
        }
        
        // 🚀 Fetch regular batches (only if not searching for specific favorites)
        if (!currentQuery || currentQuery.toLowerCase() === 'batch') {
          let nameQuery = currentQuery ? `&name=${encodeURIComponent(currentQuery)}` : '';
          const apiUrl = `${API_BASE}/batches/search?page=${currentPage}${nameQuery}`;
          
          console.log('📡 Fetching regular batches from Secret Proxy:', apiUrl);

          const res = await fetch(apiUrl);
          const data = await res.json();

          console.log('📦 Secret Proxy Response:', data);
          console.log('📊 Regular batches received:', data.data?.length || 0);
          console.log('✅ API Success:', data.success);

          // Add regular batches to the list (avoid duplicates with favorites)
          const regularBatches = data.data || [];
          const favoriteIds = serverFilteredBatches.map(b => b.batchId);
          const uniqueRegularBatches = regularBatches.filter(b => !favoriteIds.includes(b._id));
          
          const mappedRegularBatches = uniqueRegularBatches.map(b => ({
            name: b.name,
            image: b.previewImage?.key ? `https://static.pw.live/${b.previewImage.key}` : null,
            batchId: b._id,
            startDate: b.startDate
          }));
          
          serverFilteredBatches = [...serverFilteredBatches, ...mappedRegularBatches];
          console.log('🔄 Combined total batches:', serverFilteredBatches.length);
        } else {
          // Custom search query - search normally
          const apiUrl = `${API_BASE}/batches/search?page=${currentPage}&name=${encodeURIComponent(currentQuery)}`;
          console.log('🔍 Custom search for:', currentQuery, 'at:', apiUrl);
          
          const res = await fetch(apiUrl);
          const data = await res.json();
          
          const searchResults = data.data || [];
          serverFilteredBatches = searchResults.map(b => ({
            name: b.name,
            image: b.previewImage?.key ? `https://static.pw.live/${b.previewImage.key}` : null,
            batchId: b._id,
            startDate: b.startDate
          }));
        }
        
        console.log('✅ Server-side filtering complete:', serverFilteredBatches.length, 'batches');

        // Batches are already mapped in the new logic above
        const newBatches = serverFilteredBatches;

        if (serverFilteredBatches.length === 0) {
          renderNoResults();
          hasMore = false;
          setTimeout(() => {
            showLoader(false);
          }, 800);
        } else {
          allBatches = reset ? newBatches : allBatches.concat(newBatches);
          // Show batches immediately
          sortAndRenderBatches();
          showLoader(false);

          // Update pagination - if we got 20 batches, there might be more
          hasMore = serverFilteredBatches.length === 20;
          if (hasMore) {
            currentPage++;
          }
        }
      } catch (err) {
        console.error("❌ Failed to load batches:", err);
        showLoader(false);
      } finally {
        isLoading = false;
      }
    }




    function renderBatches(batches, { append = false } = {}) {
      if (!append) main.innerHTML = "";

      todayWrapper.style.display = "none";
      backBtn.style.display = "none";
      searchInput.style.display = "block";
      // loadMoreBtnWrapper.style.display = "block"; // Removed as we no longer have this button

      batches.forEach(batch => {
        appendCard(main, batch.name, batch.image, batch.batchId, () => {
          currentBatchName = batch.name;
          loadSubjects(batch.batchId);
        });
      });
    }

    function renderNoResults() {
      main.innerHTML = `
    <div style="text-align:center; color:#666; padding:2rem;">
      <p>🔍 No batches found.</p>
    </div>
  `;
    }

    window.addEventListener("scroll", () => {
      const nearBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 100;

      const isBatchesView =
        main.style.display !== "none" &&
        subjectsDiv.style.display === "none" &&
        chaptersDiv.style.display === "none" &&
        document.getElementById("lectureSection").style.display === "none" &&
        document.getElementById("todayWrapper").style.display === "none";

      if (nearBottom && isBatchesView && !isLoading) {
        loadBatches();
      }
    });
    ;




    // 🔍 Search input listener
    searchInput.addEventListener("input", debounce(() => {
      currentQuery = searchInput.value.trim();
      loadBatches({ reset: true });
    }, 300));

    // Utility: debounce
    function debounce(fn, delay) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
      };
    }


    async function loadSubjects(batchId) {
      // Update URL to reflect current view
      history.pushState({}, '', `?batch=${batchId}`);
      show(subjectsDiv);
      backBtn.style.display = "block";

      subjectsDiv.innerHTML = "";
      searchInput.style.display = "none";
      showLoader(true);
      try {
        const res = await fetch(`${API_BASE}/batch/${encodeURIComponent(batchId)}/details`);
        const json = await res.json();
        const subs = (json.data && json.data.subjects) || [];

        // If no subjects, show message
        if (subs.length === 0) {
          subjectsDiv.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-folder-times" style="margin-right: 8px; opacity: 0.7;"></i>Failed to load batch subjects.</div>';
          showLoader(false);
          return;
        }

        // 1. Define appendCard FIRST
        function appendCard(container, sub, onClick) {
          const subjectName = sub.subject;
          const iconUrl = sub.imageId ? `${sub.imageId.baseUrl}${sub.imageId.key}` : '';
          const lectureCount = sub.lectureCount || 0;
          const chapterCount = sub.tagCount || 0;

          const teacher = sub.teacherIds?.[0];
          const teacherImg = teacher?.imageId
            ? `${teacher.imageId.baseUrl}${teacher.imageId.key}`
            : '';
          const teacherName = teacher ? `${teacher.firstName} ${teacher.lastName}` : 'TBA';

          const card = document.createElement('div');
          card.className = 'subject-card';
          card.onclick = onClick;

          card.innerHTML = `
    <div class="card-header">
      <img class="subject-icon" src="${iconUrl}" alt="${subjectName}" />
      <div class="subject-title">${subjectName}</div>
    </div>
    <div class="card-details">
      <div>🎥 <strong>${lectureCount}</strong> Lectures</div>
      <div>📚 <strong>${chapterCount}</strong> Chapters</div>
    </div>
    <div class="teacher-info">
      <img class="teacher-img" src="${teacherImg}" alt="${teacherName}" />
      <div class="teacher-name">${teacherName}</div>
    </div>
  `;

          container.appendChild(card);
        }

        // 2. Then call it inside your loop
        subs.forEach(sub => {
          appendCard(subjectsDiv, sub, () => {
            chapterPage = 1;
            chapterLoading = false;
            
            // Use the subject slug for API calls (existing code compatibility)
            const subjectSlug = sub.slug || sub.subjectSlug || sub.subject.toLowerCase().replace(/[^a-z0-9]+/g, '-');
            // Use subject ID for new attachment-links endpoint (V3 API requires IDs)
            currentSubjectId = sub._id || '';
            currentSubjectSlug = subjectSlug; // Keep for compatibility with existing code
            currentSubjectName = sub.subject;
            loadChapters(batchId, subjectSlug);
          });
        });

        // TODO: Add today's schedule endpoint to proxy when needed
        // For now, we'll skip today's classes since the old endpoint needs proxy support
        const todayClasses = [];
        const todayWrapper = document.getElementById("todayWrapper");
        const todayScrollContainer = document.getElementById("todayScrollContainer");

        if (document.getElementById("subjects").style.display !== "none") {
          todayWrapper.style.display = "block";
        }


        // If no live classes, show message
        if (todayClasses.length === 0) {
          todayScrollContainer.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-calendar-times" style="margin-right: 8px; opacity: 0.7;"></i>No live classes today.</div>';
        } else {
          todayScrollContainer.innerHTML = ""; // Clear previous content
        }

        // Loop through today's classes
        todayClasses.forEach(cls => {
          const title = cls.topic || "Untitled";
          const subject = cls.subjectId?.name || "Unknown Subject";
          const time = new Date(cls.startTime).toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
          const chapter = cls.tags?.[0]?.name || "General";
          const tagLabel = cls.tag || "Upcoming";

          const statusColor = tagLabel === "Live"
            ? "#00FF88"  // Bright green for live
            : tagLabel === "Ended"
              ? "#FF4444"  // Red for ended
              : "#2196F3"; // Blue for upcoming

          const card = document.createElement("div");
          card.className = "today-card";

          // Required for horizontal scroll layout
          card.style.width = "260px";
          card.style.flex = "0 0 auto";

          card.innerHTML = `
    <div style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 5px;">${subject}</div>
    <div class="today-card-title">${title}</div>
    <div style="font-size: 0.85rem; margin-top: 5px;">🕒 ${time} IST</div>
    <div style="margin-top: 5px; font-size: 0.8rem; background: var(--bg-tertiary); padding: 4px 8px; border-radius: 6px; display: inline-block;">${chapter}</div>
    <div class="status-tag" style="position: absolute; top: 10px; right: 10px; background: ${statusColor}; color: black; font-weight: bold; font-size: 0.75rem; padding: 2px 6px; border-radius: 6px;">${tagLabel}</div>
    <div class="today-play-button">
          <i class="fas fa-play"></i>
        </div>
  `;

          card.onclick = async () => {
            if (tagLabel === "Upcoming") {
              showNotification("Class not started yet. Please wait.", 'warning');
              return;
            }

            const batchId = cls.batch?._id || cls.batchId?._id || cls.batchId; // support for both structures
            const scheduleId = cls._id;

            if (!batchId || !scheduleId) {
              alert("Invalid class identifiers.");
              return;
            }

            showLoader(true);

            try {
              const res = await fetch(`${API_BASE}/api/url?batch_id=${batchId}&schedule_id=${scheduleId}`);
              const data = await res.json();

              if (data.success && data.signed_url && data.video_id) {
                const urlParams = new URLSearchParams({
                  encrypted: data.signed_url,
                  iv: data.video_id
                });
                if (data.pally_data && data.pally_iv) {
                  urlParams.append('pally_data', data.pally_data);
                  urlParams.append('pally_iv', data.pally_iv);
                }
                window.location.href = `player?${urlParams.toString()}`;
              } else {
                alert("⚠️ Failed to get live stream URL.");
              }
            } catch (err) {
              console.error("Live stream fetch error:", err);
              alert("⚠️ Error getting live stream URL.");
            } finally {
              showLoader(false);
            }
          };


          todayScrollContainer.appendChild(card);
        });
      } catch (err) {
        console.error("Failed to load subjects or todayclass:", err);
      } finally {
        showLoader(false);
      }
    }

    async function loadChapters(batchId, subjectId) {
      const chaptersDiv = document.getElementById("chaptersDiv");
      const oldWrapper = document.getElementById("chapterLoadMoreWrapper");
      if (oldWrapper) oldWrapper.remove();

      if (chapterLoading) return;

      // Update URL to reflect current view
      history.pushState({}, '', `?batch=${batchId}&subject=${subjectId}`);
      chaptersDiv.innerHTML = "";
      clearAll();
      document.getElementById("subjects").style.display = "none";
      searchInput.style.display = "none"; // Hide search input when viewing chapters

      chapterLoading = true;
      showLoader(true);

      currentBatchId = batchId;
      currentSubjectSlug = subjectId; // Keep the variable name for compatibility
      
      // Ensure currentSubjectId is set (needed for attachment-links)
      if (!currentSubjectId && currentBatchId && currentSubjectSlug) {
        // Fetch subject ID based on batchId and subjectSlug
        try {
          const batchRes = await fetch(`${API_BASE}/batch/${currentBatchId}/details`);
          const batchData = await batchRes.json();
          const subjects = (batchData.data && batchData.data.subjects) || [];
          const subject = subjects.find(sub => 
            (sub.slug || sub.subjectSlug || sub.subject.toLowerCase().replace(/[^a-z0-9]+/g, '-')) === currentSubjectSlug
          );
          if (subject && subject._id) {
            currentSubjectId = subject._id;
            console.log('Retrieved subject ID from batch details:', currentSubjectId); // TEMP DEBUG
          }
        } catch (error) {
          console.error('Error fetching subject ID:', error);
        }
      }

      try {
        const res = await fetch(`${API_BASE}/batch/${batchId}/subject/${subjectId}/topics?page=1&batchTagType=UNITS&limit=20`);
        const result = await res.json();

        const chapters = result.data || [];

        if (chapters.length === 0) {
          chaptersDiv.innerHTML = '<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-book-open" style="margin-right: 8px; opacity: 0.7;"></i>No chapters found.</div>';
        } else {
          chapters.forEach(ch => {
            const card = document.createElement("div");
            card.className = "chapter-card";
            card.innerHTML = `
          <div class="chapter-title">${ch.name}</div>
          <div class="chapter-meta">
            <div><i class="fas fa-video"></i> ${ch.lectureVideos || 0} Lectures</div>
            <div><i class="fas fa-file-alt"></i> ${ch.notes || 0} Notes</div>
            <div><i class="fas fa-book"></i> ${ch.exercises || 0} DPPs</div>
          </div>
        `;
            card.addEventListener("click", () => {
              if (!ch._id) {
                alert("Chapter ID missing. Cannot load lectures.");
                return;
              }
              pushView(() => loadChapters(batchId, subjectId));
              currentTopicName = ch.name;
              
              // Store both chapter slug (for v2 API) and tag ID (for v3 API)
              const chapterSlug = ch.slug || ch.name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
              const tagId = ch._id; // This is the actual tag ID needed for V3 API
              
              // DEBUG: Log chapter data to see what we're extracting
              console.log('DEBUG chapter click:', { chapterName: ch.name, chapterSlug, tagId, fullChapter: ch });
              
              loadLecturesContent(batchId, subjectId, chapterSlug, "LECTURES", tagId);
            });

            chaptersDiv.appendChild(card);
          });
        }

      } catch (err) {
        console.error("Failed to load chapters:", err);
        const errorMsg = document.createElement("div");
        errorMsg.className = "error-state";
        errorMsg.innerText = "Failed to load chapters. Please try again.";
        chaptersDiv.appendChild(errorMsg);
      } finally {
        showLoader(false);
        show(chaptersDiv);
        chapterLoading = false;
      }
    }

    // HTML structure for the lecture section with tabs
    /*
    <div id="lectureSection" style="display: none;">
      <div class="header">
        <h2 id="topicTitle">Lectures</h2>
        <div class="back-button" onclick="history.back()">
          <i class="fas fa-arrow-left"></i>
        </div>
      </div>
      
      <div class="tabs">
        <button id="tab-lectures" class="tab active" onclick="switchLectureTab('lectures')">Lectures</button>
        <button id="tab-notes" class="tab" onclick="switchLectureTab('notes')">Notes</button>
        <button id="tab-dppnotes" class="tab" onclick="switchLectureTab('dppnotes')">DPP Notes</button>
        <button id="tab-dpplecture" class="tab" onclick="switchLectureTab('dpplecture')">DPP Videos</button>
      </div>
      
      <div id="lectureContent" class="content-grid"></div>
    </div>
    */

    // Function to switch between lecture tabs
    function switchLectureTab(tab) {
      // Updated mapping to use correct API contentType values
      const typeMap = {
        lectures: "LECTURES",    // Use LECTURES API type directly
        notes: "ALL",          // Use ALL and filter for notes client-side
        dppnotes: "ALL",       // Use ALL and filter for DPP notes client-side
        dpplecture: "ALL"      // Use ALL and filter for DPP videos client-side
      };

      currentContentType = typeMap[tab] || "LECTURES";
      currentTabType = tab; // Store current tab type for filtering

      ["lectures", "notes", "dppnotes", "dpplecture"].forEach(t => {
        const tabElement = document.getElementById("tab-" + t);
        if (tabElement) {
          tabElement.classList.remove("active");
        }
      });
      
      const activeTabElement = document.getElementById("tab-" + tab);
      if (activeTabElement) {
        activeTabElement.classList.add("active");
      }

      loadLecturesContent(currentBatchId, currentSubjectSlug, currentTopicId, currentContentType);
    }

    async function loadLecturesContent(batchId, subjectId, topicId, contentType = "LECTURES", tagId = null) {
      if (lectureLoading) return;
      lectureLoading = true;

      history.pushState({}, '', `?batch=${batchId}&subject=${subjectId}&topic=${topicId}&type=${contentType}`);
      document.getElementById("lectureContent").innerHTML = "";
      searchInput.style.display = "none"; // Hide search input when viewing lectures

      show(document.getElementById("lectureSection"));

      showLoader(true);

      currentBatchId = batchId;
      currentSubjectSlug = subjectId; // Keep for compatibility
      currentTopicId = topicId; // This is the slug for backward compatibility
      currentTagId = tagId; // This is the actual tag ID needed for V3 API
      currentContentType = contentType;
      
      // DEBUG: Log what we received
      console.log('DEBUG loadLecturesContent:', { batchId, subjectId, topicId, tagId, currentTagId });
      
      // Ensure currentSubjectId is set (needed for attachment-links)
      if (!currentSubjectId && currentBatchId && currentSubjectSlug) {
        // Fetch subject ID based on batchId and subjectSlug
        try {
          const batchRes = await fetch(`${API_BASE}/batch/${currentBatchId}/details`);
          const batchData = await batchRes.json();
          const subjects = (batchData.data && batchData.data.subjects) || [];
          const subject = subjects.find(sub => 
            (sub.slug || sub.subjectSlug || sub.subject.toLowerCase().replace(/[^a-z0-9]+/g, '-')) === currentSubjectSlug
          );
          if (subject && subject._id) {
            currentSubjectId = subject._id;
            console.log('Retrieved subject ID from batch details:', currentSubjectId); // TEMP DEBUG
          }
        } catch (error) {
          console.error('Error fetching subject ID:', error);
        }
      }

      // Use the correct v2 API format with proper contentType values
      // Map frontend tabs to v2 API contentType values
      const contentTypeMap = {
        lectures: "videos",      // v2 API uses "videos" for lectures
        notes: "notes",         // v2 API uses "notes" for notes
        dppnotes: "DppNotes",   // v2 API uses "DppNotes" for DPP notes
        dpplecture: "videos"    // DPP videos might be "videos" or could be "DppVideos"
      };
      
      const apiContentType = contentTypeMap[currentTabType] || "videos";
      
      // Get chapter slug from topicId - we need to convert the MongoDB ID to slug
      // For now, we'll pass the topicId as tag parameter
      const url = `${API_BASE}/batch/${batchId}/subject/${subjectId}/contents?page=1&contentType=${apiContentType}&tag=${topicId}`;

      try {
        const res = await fetch(url);
        const data = await res.json();
        
        // Handle v2 API response structure
        const allItems = data.data || data.results || [];
        console.log('API Response:', data); // Debug log
        console.log('Items received:', allItems.length);

        const lectureContent = document.getElementById("lectureContent");
        if (!Array.isArray(allItems) || allItems.length === 0) {
          lectureContent.innerHTML = `<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-folder-open" style="margin-right: 8px; opacity: 0.7;"></i>No content found for this type.</div>`;
          return;
        }

        // Since v2 API already filters by contentType, we just need to process all returned items
        let processedItems = [];
        const currentTab = currentTabType || "lectures";
        
        console.log('Current tab:', currentTab);
        console.log('All items structure:', allItems[0]); // Debug: log first item structure
        
        // v2 API already filtered by contentType, so use all returned items
        const filteredItems = allItems;
        
        // Check if we have any filtered items
        if (filteredItems.length === 0) {
          lectureContent.innerHTML = `<div style="color: var(--text-muted); padding: 20px; text-align: center; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin: 10px; border: 1px solid rgba(255, 255, 255, 0.1); font-size: 0.9rem;"><i class="fas fa-folder-open" style="margin-right: 8px; opacity: 0.7;"></i>No content found for this tab.</div>`;
          return;
        }
        
        // Process items and expand homeworkIds array for notes/DPP
        processedItems = [];
        filteredItems.forEach(item => {
          const itemData = item.data || item;
          
          if ((currentTab === "notes" || currentTab === "dppnotes") && itemData.homeworkIds && itemData.homeworkIds.length > 0) {
            // For notes/DPP, create separate cards for each homework item
            itemData.homeworkIds.forEach(homework => {
              processedItems.push({
                ...item,
                scheduleId: item._id || item.id,
                data: item,
                homework: homework, // Add homework data for easy access
                _id: homework._id,  // Use homework ID for uniqueness
                title: homework.topic || homework.name || homework.title || "Untitled"
              });
            });
          } else {
            // For videos/lectures, use the main item
            processedItems.push({
              ...item,
              scheduleId: item._id || item.id,
              data: item
            });
          }
        });

        processedItems.forEach(item => {
          const div = document.createElement("div");
          div.className = "card";
          
          // Extract title from processed item structure
          let topicTitle = "Untitled";
          
          if (currentTab === "notes" || currentTab === "dppnotes") {
            // For notes/DPP, use the title we set during processing or homework data
            if (item.title) {
              topicTitle = item.title;
            } else if (item.homework) {
              const homework = item.homework;
              if (homework.topic) {
                topicTitle = homework.topic;
              } else if (homework.name) {
                topicTitle = homework.name;
              } else if (homework.title) {
                topicTitle = homework.title;
              }
            }
          } else {
            // For videos/lectures, try common title fields
            const itemData = item.data || item;
            if (itemData.name) {
              topicTitle = itemData.name;
            } else if (itemData.title) {
              topicTitle = itemData.title;
            } else if (itemData.topic) {
              topicTitle = itemData.topic;
            } else if (item.name) {
              topicTitle = item.name;
            } else if (item.title) {
              topicTitle = item.title;
            } else if (item.topic) {
              topicTitle = item.topic;
            }
          }

          if (currentTab === "notes" || currentTab === "dppnotes") {
            const scheduleId = item.scheduleId || item._id; // Use the preserved scheduleId
            const isNote = currentTab === "notes";
            const cardClass = isNote ? "note-card" : "dpp-card";
            const iconClass = isNote ? "note-icon" : "dpp-icon";
            const contentClass = isNote ? "note-content" : "dpp-content";
            const titleClass = isNote ? "note-title" : "dpp-title";
            const labelClass = isNote ? "note-label" : "dpp-label";
            const arrowClass = isNote ? "note-arrow" : "dpp-arrow";
            const iconEmoji = isNote ? "📝" : "📋";
            const labelText = isNote ? "NOTE" : "DPP";

            div.className = cardClass;
            div.innerHTML = `
    <div class="${contentClass === "note-content" ? "note-card-content" : "dpp-card-content"}">
      <div class="${iconClass}">
        ${iconEmoji}
      </div>
      <div class="${contentClass}">
        <div class="${titleClass}">${topicTitle}</div>
        <div class="${labelClass}">${labelText}</div>
      </div>
      <div class="${arrowClass}">
        >
      </div>
    </div>
  `;

            div.onclick = async () => {
              // Use V1 schedule details API endpoint to get valid attachment keys
              try {
                showLoader(true);
                const scheduleId = item.scheduleId || item._id;
                const subjectSlug = currentSubjectSlug; // Pass the subject slug for V1 API
                
                console.log('V1 API attachment-links request:', { scheduleId, subjectSlug, batchId: currentBatchId, subjectId: currentSubjectId });
                
                const res = await fetch(`${API_BASE}/batch/${currentBatchId}/subject/${currentSubjectId}/attachment-links?scheduleId=${scheduleId}&subjectSlug=${subjectSlug}`);
                const data = await res.json();
                
                if (data.success && data.data && data.data.length > 0) {
                  // Open each attachment with valid keys from V1 API
                  data.data.forEach(att => {
                    console.log('Opening PDF with V1 key:', att.url);
                    window.open(att.url, '_blank');
                  });
                } else {
                  // Fallback: try with v2 API data if V1 fails
                  if (item.homework && item.homework.attachmentIds && item.homework.attachmentIds.length > 0) {
                    console.log('Fallback: Using v2 API data (may have empty keys)');
                    item.homework.attachmentIds.forEach(att => {
                      const fileUrl = `${att.baseUrl}${att.key}`;
                      window.open(fileUrl, '_blank');
                    });
                  } else {
                    console.log('V1 API response:', data);
                    alert('No attachments found for this item.');
                  }
                }
              } catch (error) {
                console.error('Error fetching attachment links:', error);
                alert('Error loading attachments. Please try again.');
              } finally {
                showLoader(false);
              }
            };
          }
          else {
            const itemData = item.data || item;
            const vid = itemData.videoDetails || itemData;
            
            // Debug: log the data structure
            console.log('Item data structure:', {
              itemData: itemData,
              videoDetails: itemData.videoDetails,
              topic: itemData.topic,
              image: itemData.videoDetails?.image,
              duration: itemData.videoDetails?.duration,
              date: itemData.date,
              startTime: itemData.startTime,
              createdAt: itemData.videoDetails?.createdAt
            });
            
            const title = itemData.topic || itemData.videoDetails?.name || "Untitled Video";
            const image = itemData.videoDetails?.image || "";
            const mediaUrl = itemData.videoDetails?.videoUrl || itemData.url || "";
            const duration = itemData.videoDetails?.duration || "00:00:00";

            // Use the date field or startTime, fallback to createdAt
            const lectureDate = itemData.date || itemData.startTime || itemData.videoDetails?.createdAt;
            const startTime = new Date(lectureDate);
            const formattedDate = startTime.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric'
            });

            div.className = "lecture-card";
            div.innerHTML = `
    <div class="lecture-card-inner">
      <div class="lecture-thumbnail">
        <img src="${image}" alt="${title}" class="lecture-image" />
        <div class="video-watermark-top">
          <img src="https://www.pw.live/favicon.ico" alt="Logo" class="watermark-logo">
          @pwXavengers
        </div>
        <div class="lecture-play-button">
          <i class="fas fa-play"></i>
        </div>
      </div>
      <div class="lecture-info">
        <div class="lecture-meta">
          <span class="lecture-date">${formattedDate}</span>
          <span class="lecture-duration">${duration}</span>
        </div>
        <h3 class="lecture-title">${title}</h3>
      </div>
    </div>
  `;
            div.onclick = async () => {
              showLoader(true);
              try {
                let finalUrl = mediaUrl;
                const isYouTube = finalUrl && (finalUrl.includes('youtube.com') || finalUrl.includes('youtu.be'));
                if (isYouTube) return window.open(finalUrl, '_blank');

                const itemData = item.data || item;
                const realVid = itemData.videoDetails || itemData;
                const params = new URLSearchParams({
                  batch: currentBatchId || 'Unknown Batch',
                  subject: currentSubjectSlug || 'Unknown Subject',
                  topic: currentTopicId || 'General',
                  title: itemData.topic || itemData.videoDetails?.name || ''
                });

                const resp = await fetch(`${API_BASE}/api/video/stream-info?${params}`);
                const data = await resp.json();

                if (data.youtube && data.videoUrl) {
                  window.open(data.videoUrl, '_blank');
                  return;
                }

                if (data.success && data.signed_url && data.video_id) {
                  const urlParams = new URLSearchParams({
                    encrypted: data.signed_url,
                    iv: data.video_id
                  });
                  window.open(`player?${urlParams}`, '_blank');
                  return;
                }

                // Try the new API endpoint as a third option
                const fetchApi1 = async () => {
                  // First API endpoint (existing)
                  const scheduleId = itemData._id || item._id;
                  const res = await fetch(`${API_BASE}/api/url?batch_id=${currentBatchId}&schedule_id=${scheduleId}`);
                  const altData = await res.json();

                  if (altData.success && altData.signed_url && altData.video_id) {
                    const urlParams = new URLSearchParams({
                      encrypted: altData.signed_url,
                      iv: altData.video_id
                    });
                    if (altData.pally_data && altData.pally_iv) {
                      urlParams.append('pally_data', altData.pally_data);
                      urlParams.append('pally_iv', altData.pally_iv);
                    }
                    return { type: 'redirect', url: `player?${urlParams.toString()}` };
                  }
                  throw new Error('API 1 did not provide a valid video URL.');
                };

                const fetchApi2 = async () => {
                  // Second API endpoint (existing)
                  const resp = await fetch(`${API_BASE}/api/video/stream-info?${params}`);
                  const data = await resp.json();

                  if (data.youtube && data.videoUrl) {
                    return { type: 'open', url: data.videoUrl };
                  }

                  if (data.success && data.signed_url && data.video_id) {
                    const urlParams = new URLSearchParams({
                      encrypted: data.signed_url,
                      iv: data.video_id
                    });
                    return { type: 'open', url: `player?${urlParams}` };
                  }
                  throw new Error('API 2 did not provide a valid video URL.');
                };

                const fetchApi3 = async () => {
                  // Third API endpoint (new) - using our proxy
                  const scheduleId = item._id;
                  const res = await fetch(`${API_BASE}/api/video-data?batchId=${currentBatchId}&scheduleId=${scheduleId}`);
                  const responseJson = await res.json();

                  if (responseJson.success && responseJson.data && responseJson.iv) {
                    const urlParams = new URLSearchParams({
                      data: responseJson.data,
                      iv: responseJson.iv
                    });
                    return { type: 'redirect', url: `player?${urlParams}` };
                  }
                  throw new Error('API 3 did not provide valid video data.');
                };

                // Run all API calls in parallel and get the first success
                try {
                  const result = await Promise.any([
                    fetchApi1(),
                    fetchApi2(),
                    fetchApi3()
                  ]);

                  // Act on the first successful result
                  if (result.type === 'open') {
                    window.open(result.url, '_blank');
                    showLoader(false);
                  } else if (result.type === 'redirect') {
                    window.location.href = result.url;
                  }
                } catch (error) {
                  // This block executes only if ALL promises fail
                  console.error("All video sources failed to load:", error);
                  alert("⚠️ Video not available from any source.");
                }
              } catch (err) {
                console.error("Video load failed:", err);
                alert("⚠️ Failed to load video.");
              } finally {
                showLoader(false);
              }
            };
          }
          lectureContent.appendChild(div);
        });
      } catch (err) {
        console.error("Failed to load content:", err);
      } finally {
        lectureLoading = false;
        showLoader(false);
      }
    }
    async function fetchAndOpenAttachments(batchId, subjectSlug, scheduleId) {
      try {
        showLoader(true);
        const res = await fetch(`${API_BASE}/api/batch/${batchId}/subject/${subjectSlug}/schedule/${scheduleId}/content`);
        const data = await res.json();

        if (!data.data) {
          alert("No content found.");
          return;
        }

        // Handle single object response (not array)
        const scheduleData = data.data;
        const attachments = (scheduleData.homeworkIds || []).flatMap(hw =>
          (hw.attachmentIds || [])
        );

        if (!attachments.length) {
          alert("No attachments found.");
          return;
        }

        attachments.forEach(att => {
          const fileUrl = `${att.baseUrl}${att.key}`;
          window.open(fileUrl, '_blank');
        });

      } catch (err) {
        console.error("Failed to fetch schedule content:", err);
        alert("Error loading attachments.");
      } finally {
        showLoader(false);
      }
    }

    function switchLectureTab(tab) {
      // Updated mapping to use correct API contentType values
      const typeMap = {
        lectures: "LECTURES",    // Use LECTURES API type directly
        notes: "ALL",          // Use ALL and filter for notes client-side
        dppnotes: "ALL",       // Use ALL and filter for DPP notes client-side
        dpplecture: "ALL"      // Use ALL and filter for DPP videos client-side
      };

      currentContentType = typeMap[tab] || "LECTURES";
      currentTabType = tab; // Store current tab type for filtering

      ["lectures", "notes", "dppnotes", "dpplecture"].forEach(t => {
        document.getElementById("tab-" + t).classList.remove("active");
      });
      document.getElementById("tab-" + tab).classList.add("active");

      loadLecturesContent(currentBatchId, currentSubjectSlug, currentTopicId, currentContentType, currentTagId);
    }

    backBtn.onclick = () => {
      history.back(); // ✅ triggers popstate event
    };


    searchInput.addEventListener("input", () => {
      const keyword = searchInput.value.toLowerCase();
      const filtered = allBatches.filter(b => b.name.toLowerCase().includes(keyword));
      renderBatches(filtered);
    });

    // Disable right-click and DevTools
    document.addEventListener('contextmenu', event => event.preventDefault());
    document.addEventListener('keydown', function (event) {
      if (
        event.key === "F12" ||
        (event.ctrlKey && event.shiftKey && (event.key === 'I' || event.key === 'J')) ||
        (event.ctrlKey && event.key === 'U') ||
        (event.ctrlKey && event.shiftKey && event.key === 'C') ||
        (event.ctrlKey && event.key === 'A') ||
        (event.ctrlKey && event.key === 'S') ||
        (event.ctrlKey && event.key === 'P')
      ) {
        event.preventDefault();
      }
    });
    window.addEventListener("popstate", () => {
      if (viewStack.length > 0) {
        const restoreView = viewStack.pop(); // ✅ Pop the function for the view we are returning TO.
        if (typeof restoreView === 'function') {
          restoreView(); // ✅ Execute it.
        }
      }
    });
    document.addEventListener("DOMContentLoaded", () => {
      // Check URL parameters to restore the correct view on page load
      const urlParams = new URLSearchParams(window.location.search);
      const batchId = urlParams.get("batch");
      const subjectSlug = urlParams.get("subject");
      const topicId = urlParams.get("topic");
      const contentType = urlParams.get("type") || "vidoes";

      if (batchId && subjectSlug && topicId) {
        // If batch, subject, and topic are in URL, show lecture content view
        loadLecturesContent(batchId, subjectSlug, topicId, contentType);
      } else if (batchId && subjectSlug) {
        // If both batch and subject are in URL, show chapters view
        loadChapters(batchId, subjectSlug);
      } else if (batchId) {
        // If only batch is in URL, show subjects view
        loadSubjects(batchId);
      } else {
        // Otherwise, show batches view (default)
        showBatchesView();
      }
    });


  </script>
</body>

</html>